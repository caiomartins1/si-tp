package pt.ubi.di.connection;

import pt.ubi.di.Model.Validations;
import pt.ubi.di.security.model.*;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.Socket;

public class Client_Lite {
    private final String ip;
    private final int port;
    private Socket socket;
    private ObjectInputStream inputStream;
    private ObjectOutputStream outputStream;
    private byte[] secretKey;
    private RsaKeys[] rsaKeys = new RsaKeys[2];
    private final int KEY_PAIR = 0;
    private final int PUBLIC_KEY = 1;

    public Client_Lite(String ip, int port) {
        this(ip,port,null);
    }

    /**
     * Constructor to create a new client_lite,
     * responsible to create a new connection private between a server_lite and a client_lite
     * @param ip of the serve_lite
     * @param port of the connection
     */
    public Client_Lite(String ip, int port, byte[] key) {
        this.ip = ip;
        this.port = port;
        this.secretKey = key;

        try {
            socket = new Socket(ip, port);
            inputStream = new ObjectInputStream(socket.getInputStream());
            outputStream = new ObjectOutputStream(socket.getOutputStream());

            System.out.println("Client created!");
            while (true) {
                System.out.print("Waiting for messages.....\n");
                String option =(String) inputStream.readObject();
                switch (option) {
                    case "dh":
                        secretKey = SecurityDH.receiveExchange(outputStream,inputStream);
                        System.out.println(">Key generated by Diffie-Hellman:\n" + SecurityUtil.byteArrayToHex(secretKey));
                        break;
                    case "mkp":
                        secretKey = SecurityMP.receiveExchange(outputStream, inputStream);
                        System.out.println(">Key generated by Merkle Puzzles:\n" + SecurityUtil.byteArrayToHex(secretKey));
                        break;
                    case "rsa":
                        rsaKeys = SecurityRSA.receiveExchange(outputStream,inputStream);
                        System.out.println("------------------RSA keys------------------");
                        System.out.println("My Public Key: "+ rsaKeys[KEY_PAIR].getE() + "\nMy Private Key: " + rsaKeys[KEY_PAIR].getD());
                        System.out.println("-------------------------------------------");
                        System.out.println("Shared public key: " + rsaKeys[PUBLIC_KEY].getE());
                        break;
                    case "sk":
                        secretKey = SecurityUtil.participateSessionKeys(outputStream, inputStream);
                        System.out.println(">Session key generated: " + SecurityUtil.byteArrayToHex(secretKey));
                        break;
                    case "ck":
                        String ckOption =(String) inputStream.readObject();
                        if(ckOption.equals("rsa")) {
                            System.out.println(">Starting key check...");
                            if(rsaKeys[PUBLIC_KEY] == null || rsaKeys[KEY_PAIR] == null) {
                                System.out.println("No RSA public key configured.");
                            }
                            else {
                                SecurityUtil.checkSharedKey2(outputStream, inputStream, rsaKeys[PUBLIC_KEY].getPublicKey());
                                SecurityUtil.checkSharedKey(outputStream, inputStream, rsaKeys[KEY_PAIR].getPublicKey());
                            }
                        }
                        else if(ckOption.equals("dh")) {
                            System.out.println(">Starting key check...");
                            if(secretKey == null) {
                                System.out.println("No key secret configured.");
                            }
                            else
                                SecurityUtil.checkSharedKey2(outputStream,inputStream,secretKey);
                        }
                        break;
                    case "message":
                        communicate();
                        break;
                    case "exit":
                        outputStream.close();
                        inputStream.close();
                        socket.close();
                        break;
                    default:
                        break;
                }
            }
        } catch (Exception e) {
            System.out.println("Error: " + e.getMessage());
        }
    }

    private void communicate() {
        boolean flag;
        boolean signFlag = false;
        if(secretKey == null) {
            System.out.println("No secret key configured.");
            return;
        }
        String[] options;
        try {
            options =(String[]) inputStream.readObject();
            if(SecurityUtil.lookOptions(options,new String[]{"-sign"}) != -1 && rsaKeys[KEY_PAIR].asAlgo()) { // receive and test signature
                if (!(rsaKeys[PUBLIC_KEY] == null || rsaKeys[KEY_PAIR] == null)) {
                    System.out.println("Using rsa signature for message validation.");
                    signFlag = true;
                }
            }
        } catch (Exception e) {
            System.out.println("Error receiving options.");
        }

        while(true) {
            try {
                flag =(boolean) inputStream.readObject();
                if (!flag)
                    return;
            } catch (Exception e) {
                System.out.println("Error Receiving flag.");
            }
            String receiveMessage = SecurityUtil.receiveMessage(outputStream,inputStream,secretKey);

            if(signFlag) {
                if (!SecurityRSA.receiveSignature(outputStream,inputStream,receiveMessage.getBytes(),rsaKeys[PUBLIC_KEY]))
                    System.out.println("\n>Signature invalid, do not trust the message.");
            }

            System.out.println(receiveMessage);
            System.out.print("message>");
            String message = Validations.readString();
                try {
                    if (message == null)
                        message = "";
                    else if (message.equals("-exit")) {
                        outputStream.writeObject(false);
                        return;
                    }
                    outputStream.writeObject(true);
                } catch (Exception e) {
                    System.out.println("Error sending flag.");
                }
            SecurityUtil.sendMessage(outputStream,inputStream,message,secretKey,new String[]{});
            if(signFlag) {
                SecurityRSA.sendSignature(outputStream,inputStream,message.getBytes(),rsaKeys[KEY_PAIR]);
            }
        }
    }

}
